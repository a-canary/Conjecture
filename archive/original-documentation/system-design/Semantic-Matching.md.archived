---
archived: 2024-10-30
reason: Content consolidated into new unified documentation
consolidated_into: ProcessingWorkflows.md
migration_status: complete
quality_note: Replaced by higher-quality unified documentation
---

# Semantic Matching - Action Processing and Selection

## Executive Summary

Semantic Matching transforms Conjecture from static tool routing to dynamic semantic intelligence by generating actionable intent descriptions, comparing them semantically against available capabilities, and selecting optimal tools through intelligent scoring algorithms. The system bridges user context to capability execution through conceptual understanding rather than keyword patterns.

## Core Philosophy

### Semantic Intelligence Over Pattern Matching

Traditional systems rely on keyword matching, predefined categories, or manual routing rules. Semantic Matching uses deep semantic understanding to conceptualize user intent and match it against capability descriptions, enabling flexible adaptation to new situations without manual configuration.

### Confidence-Driven Selection

Every match includes confidence assessment based on semantic similarity, historical success patterns, and contextual relevance, ensuring the system selects not just theoretically relevant tools but practically effective ones.

## Action Generation Process

### Context Analysis

The system generates semantic action descriptions from current evidence and query context:

```
Action Generation Process:
├─ Evidence Review → Identify key concepts and relationships
├─ Context Analysis → Understand current research focus
├─ Intent Extraction → Derive actionable objectives
└─ Action Synthesis → Generate comprehensive action descriptions
```

### Action Description Structure

Generated actions follow a consistent format for effective matching:

```
Action Description Format:
"Perform [specific action] using [methodology] to achieve [objective] with focus on [constraints/considerations]"
```

**Examples**:
- "Analyze customer churn patterns using statistical methods to identify at-risk segments with focus on retention strategies"
- "Generate visualization of financial data using time series analysis to detect trends with emphasis on seasonal patterns"
- "Research competitive landscape using market intelligence to identify strategic opportunities with consideration of emerging technologies"

### Action Quality Criteria

Generated actions must meet quality standards:

- **Specificity**: Clear action objectives and methods
- **Feasibility**: Practical applicability within system capabilities
- **Context Relevance**: Direct connection to current evidence and queries
- **Completeness**: Comprehensive description of scope and considerations

## Embedding Generation and Comparison

### Embedding Creation

All semantic elements are converted to vector representations:

```
Embedding Generation Process:
Query Context + Available Evidence → Action Generation → Embedding Creation
├─ Query Context Analysis → Understanding research focus and intent
├─ Evidence Review → Identifying relevant concepts and relationships
├─ Action Description Generation → Creating actionable intent descriptions
└─ Vector Embedding → Converting text to semantic vectors
```

### Embedding Sources

Multiple semantic elements contribute to the matching process:

```
Embedding Sources:
├─ Action Descriptions → Generated from current context and intent
├─ Skill Descriptions → Pre-computed from skill.md capability descriptions
├─ Query Hints → (Optional) User-provided capability suggestions
└─ Historical Patterns → Embedded successful query-skill combinations
```

### Semantic Similarity Calculations

Vector similarity determines conceptual alignment between actions and capabilities:

```
Similarity Matrix:
┌─────────────────────────────────────────────────────────┐
│ Actions vs Skills ── Embedding Vectors ── Similarity Scores │
├─────────────────────────────────────────────────────────┤
│ Action 1 v Skill A: 0.87 │ Action 1 v Skill B: 0.65    │
│ Action 2 v Skill A: 0.73 │ Action 2 v Skill C: 0.91    │
│ Action 3 v Skill B: 0.94 │ Action 3 v Skill D: 0.58    │
└─────────────────────────────────────────────────────────┘
```

## Skill Selection Algorithm

### Scoring Components

Multiple factors influence final skill selection:

```
Selection Score = (Semantic Similarity × 40%) + (Historical Success × 30%) + (User Preference × 20%) + (Contextual Relevance × 10%)
```

**Semantic Similarity (40%)**: Core conceptual alignment between action intent and skill capability

**Historical Success (30%)**: Track record of skills succeeding in similar contexts

**User Preference (20%)**: User approval patterns and selection tendencies

**Contextual Relevance (10%)**: Specific relevance to current evidence and query context

### Sum-Ranking Process

All generated actions contribute to final skill selection:

```
Sum-Ranking Algorithm:
1. Generate 5 semantic action descriptions from context
2. Match all actions against all available skills
3. Calculate confidence scores for each action-skill pair
4. Sum-rank skills across all action-skill matches
5. Deduplicate overlapping skill selections
6. Select top-3 unique skills by final score
```

### Deduplication Strategy

Redundant capabilities are identified and removed:

```
Deduplication Process:
├─ Skill Functionality Analysis → Identify overlapping capabilities
├─ Semantic Similarity Assessment → Compare skill descriptions
├─ Historical Performance Comparison → Compare success patterns
└─ Optimal Selection → Choose highest-confidence unique capabilities
```

## Skill Gap Detection Integration

### Gap Identification Criteria

When no adequate matches are found, skill gaps are triggered:

```
Gap Detection Thresholds:
├─ Highest skill confidence < 30% for all actions
├─ Multiple skills available but none > 40% similarity
├─ Critical intent keywords with no matching capabilities
└─ Context demands specialized functionality not available
```

### Gap Handling Workflow

Skills gaps initiate capability expansion process:

```
Gap Resolution Process:
├─ Gap Detection → Confirm genuine capability shortage
├─ Child Query Generation → Create skill brainstorming query
├─ Skill Proposal Generation → LLM generates candidate skills
├─ User Approval Workflow → User selects desired capabilities
├─ Skill Integration ← Approved skills added to registry
└─ Retry Selection → Enhanced capability matching
```

## Performance Optimization

### Embedding Optimization

```
Optimization Strategies:
├─ Embedding Caching → Frequent action patterns cached for instant access
├─ Batch Generation → Multiple action embeddings generated simultaneously
├─ Similarity Pre-computation → Common skill combinations pre-matched
└─ Priority Indexing → Frequently successful skills indexed for rapid access
```

### Scoring Optimization

```
Performance Enhancements:
├─ Adaptive Weighting → Adjust scoring weights based on context type
├─ Predictive Selection → Anticipate skills likely to succeed
├─ Parallel Processing → Multiple action descriptions processed concurrently
└─ Result Caching → Cache successful skill combinations
```

### Resource Management

```
Efficiency Measures:
├─ Lazy Loading → Skills loaded only when selected for matching
├─ Embedding Compression → Memory-efficient vector storage
├─ Index Optimization → Accelerated similarity calculations
└─ Result Filtering → Process only promising candidates
```

## Quality Assurance

### Semantic Validation

```
Quality Controls:
├─ Action Coherence → Validate logical action descriptions
├─ Skill Relevance → Ensure skill descriptions match capabilities
├─ Similarity Thresholds → Minimum similarity requirements for matching
├─ Consistency Checking → Validate scoring algorithm behavior
└─ Performance Monitoring → Track selection accuracy and success rates
```

### Error Handling

```
Recovery Strategies:
├─ Low Confidence Matches → Request clarification or alternative approaches
├─ No Suitable Skills → Trigger skill gap detection and creation
├─ Scoring Anomalies → Fallback to conservative selection strategies
├─ Performance Degradation → Simplify matching algorithm temporarily
└─ System Errors → Graceful degradation with basic capability selection
```

## Integration Interfaces

### Evidence System Interface

```
Evidence Integration:
├─ Claim Retrieval → Access relevant evidence for action generation
├─ Confidence Inheritance → Incorporate claim confidence into scoring
├─ Source Context → Include source relevance in action generation
└─ Query Context → Understand current research focus and intent
```

### Capability System Interface

```
Skill Integration:
├─ Skills Registry Access → Retrieve skill descriptions and metadata
├─ Tool Definition Access → Understand skill execution capabilities
├─ Permission Integration → Consider skill permissions in selection
└─ Historical Data → Access performance patterns and success metrics
```

### Processing Engine Interface

```
Processing Coordination:
├─ Action Generation Request → Generate semantic actions from context
├─ Skill Selection Result → Provide ranked skill selections
├─ Gap Detection Signals → Alert when capabilities insufficient
├─ Performance Metrics → Track selection accuracy and efficiency
└─ Learning Feedback → Provide data for algorithm improvement
```

## Success Metrics

### Performance Indicators

```
Matching Success Metrics:
├─ Selection Accuracy: % of selected skills successfully execute tasks
├─ Semantic Precision: Quality of semantic understanding and matching
├─ Gap Detection Rate: Accuracy of capability shortage identification
├─ User Satisfaction: User approval of selected capabilities
├─ Processing Efficiency: Time and resource consumption per match
└─ Learning Effectiveness: Improvement in selection over time
```

### Quality Metrics

```
Quality Assurance Metrics:
├─ Action Coherence: Logical consistency of generated actions
├─ Skill Relevance: Appropriateness of selected capabilities
├─ Scoring Consistency: Reliability of scoring algorithm outputs
├─ Error Recovery: Success rate of error handling procedures
└─ Performance Optimization: Effectiveness of optimization strategies
```

## Evolution Path

### Advanced Semantic Understanding

Future enhancements will include:

```
Intelligence Expansion:
├─ Contextual Understanding → Deeper comprehension of domain-specific nuances
├─ Predictive Matching → Anticipate effective skill combinations
├─ Cross-Domain Transfer → Apply learning across different contexts
├─ Natural Language Refinement → Improved action and skill descriptions
└─ Adaptive Learning → Continuous improvement through interaction patterns
```

Semantic Matching provides the intelligent bridge between user context and system capabilities, transforming static tool selection into dynamic semantic understanding that continuously improves through use and adapts to evolving user needs.
