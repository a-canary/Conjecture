---
archived: 2024-10-30
reason: Content consolidated into new unified documentation
consolidated_into: SystemArchitecture.md + ProcessingWorkflows.md
migration_status: complete
quality_note: Replaced by higher-quality unified documentation
---

# Query Management - Lifecycle and Resource Control

## Executive Summary

Query Management transforms research planning from linear conversation to systematic evidence gathering through intelligent query lifecycle management. The system maintains structured research processes with priority-based processing, automatic dependency resolution, and resource-constrained optimization, ensuring efficient exploration of complex topics without unbounded growth.

## Core Philosophy

### Systematic Research Planning

Traditional AI systems handle queries as independent, one-off requests. Query Management treats each query as part of a structured research graph where questions spawn child queries, maintain relationships, and resolve through evidence accumulation.

### Priority-Driven Processing

Not all questions deserve equal attention. Query Management prioritizes research focus based on root relevance, evidence availability, and dependency resolution, ensuring computational resources concentrate on the most impactful research branches.

## Query Lifecycle States

### State Definitions

```
PENDING: Query needs processing and is available for selection
PROCESSING: Query has generated child queries and waits for resolution
RESOLVED: Query has been answered by high-confidence matching claims
ORPHANED: Query is no longer requested by any parent query
```

### State Transition Logic

```
PENDING → PROCESSING: Query generates child queries for comprehensive investigation
PROCESSING → PENDING: All direct children resolve, making parent available again
PENDING/PROCESSING → RESOLVED: High-confidence claims directly answer the query
PENDING/PROCESSING → ORPHANED: Parent query resolves, making this query irrelevant
RESOLVED/ORPHANED → Child Orphaning: ALL direct children in PENDING/PROCESSING become ORPHANED
```

### State Management Algorithm

```
Query Processing Loop:
1. Select next PENDING query (highest priority)
2. Check for blocking dependencies
3. If no blocks → PROCESSING → Generate child queries
4. Wait for children to resolve → PENDING again
5. Check for evidence match → RESOLVED OR continue processing
6. Parent resolution → Child ORPHANING cascade
```

## Priority Scoring System

### Priority Components

Query priority is calculated through weighted scoring:

```
Priority Score = (Root Relevance × 50%) + (Evidence Availability × 30%) + (Child Resolution Potential × 20%)
```

**Root Relevance (50%)**:
- Semantic similarity to original research question
- Direct lineage importance to core research goals
- User-specified priority levels when applicable

**Evidence Availability (30%)**:
- Number of available relevant claims in evidence base
- Confidence score distribution of available evidence
- Source quality and diversity of supporting evidence

**Child Resolution Potential (20%)**:
- Number of unresolved child queries
- Likelihood of children providing comprehensive answer
- Complexity and feasibility of child completion

### Selection Algorithm

```
Query Selection Process:
├─ Filter PENDING queries only
├─ Check for blocking dependencies (no unresolved children)
├─ Calculate priority scores for candidates
├─ Tie-break by creation time (older queries first)
└─ Select highest priority query
```

## Child Query Generation

### Child Creation Strategy

When queries lack direct evidence or require systematic investigation, the system generates child queries:

```
Parent Query: "Develop customer retention strategy for high-churn segments"
├─ Child	Query 1: "Identify high-churn customer segments using historical data"
├─ Child	Query 2: "Research industry best practices for customer retention"
├─ Child Query 3: "Analyze current retention program effectiveness"
└─ Child Query 4: "Evaluate competitive retention strategies"
```

### Dependency Management

Child queries create dependency relationships that govern processing order:

```
Dependency Graph:
Root Query (Customer Retention Strategy)
├─ q75.1: Identify segments (DEPENDS_ON: none)
├─ q75.2: Research practices (DEPENDS_ON: none)
├─ q75.3: Analyze programs (DEPENDS_ON: q75.1)
└─ q75.4: Competitive evaluation (DEPENDS_ON: q75.1, q75.2)
```

### Query Limits and Constraints

**Maximum 20 Queries Per Response**: Prevents uncontrolled query explosion and maintains manageable processing scope.

**Query Depth Limits**: Restricts child query generation depth to prevent infinite recursion.

**Duplicate Detection**: Semantic similarity filtering prevents redundant child queries.

## Resource Management

### Database Size Management

```
Resource Constraints:
├─ Database Size Limit: 500MB (default)
├─ Purge Trigger: When limit exceeded → Remove 10%
└─ Purge Strategy: Low confidence + resolved/orphaned queries
```

### Intelligent Pruning Strategy

```
Prune Priority (highest removal first):
1. Resolved queries with confidence < 0.30
2. Orphaned queries regardless of confidence
3. Resolved queries with confidence 0.30-0.50
4. Long-standing PENDING queries (>30 days)
5. Low-confidence claims (<0.20) not linked to active queries
```

### Performance Optimization

**Indexing Strategy**:
- Priority score index for rapid selection
- State management index for efficient filtering
- Parent-child relationship index for dependency resolution

**Caching Strategy**:
- Priority scoring results for recent queries
- Dependency analysis results for query graphs
- Resolution patterns for similar query types

## Resolution and Orphaning

### Automatic Resolution

When high-confidence claims directly answer queries:

```
Resolution Criteria:
├─ Claim similarity > 0.90 to query intent
├─ Claim confidence > 0.70 minimum threshold
├─ Multiple supporting claims strengthen resolution
└─ Source quality meets minimum requirements
```

### Orphaning Cascade Effect

```
Orphaning Logic:
Parent Query RESOLVED →
├─ Direct Child q75.1 (PENDING) → ORPHANED
├─ Direct Child q75.2 (PROCESSING) → ORPHANED
├─ Grandchild q75.1.1 (PENDING) → ORPHANED
└─ Grandchild q75.2.1 (PROCESSING) → ORPHANED
```

### Resolution Statement Integration

Resolved queries generate resolution statements for context tracking:

```
<resolution query_id="q75" timestamp="2024-01-15T10:30:00Z">
Customer retention strategy query resolved using claims c142-c145 with 85% confidence
Spawned follow-up queries: q78 (implementation strategy), q79 (cost analysis)
</resolution>
```

## Integration Interfaces

### Evidence System Integration

```
Claim Integration:
├─ Query resolution through claim matching
├─ Claim generation from child query processing
├─ Confidence scoring inheritance from sources
└─ Source reference linking for traceability
```

### Processing Engine Integration

```
Processing Coordination:
├─ Query selection for processing
├─ Child query generation and dependency management
├─ Resolution status reporting
└─ Historical context provision
```

### User Interface Integration

```
Query Visibility:
├─ Active research progress tracking
├─ Dependency relationship visualization
├─ Resolution status communication
└─ Priority influence options
```

## Error Handling and Recovery

### Dependency Cycles

```
Cycle Detection Algorithm:
├─ Track parent-child relationships as directed graph
├─ Detect cycles through graph traversal
├─ Break cycles by removing lowest-priority link
└─ Re-calculate priorities affected by changes
```

### Stalled Query Recovery

```
Stalled Query Indicators:
├─ PENDING > 30 days without progress
├─ Repeated processing without resolution
├─ Child queries all orphaned or resolved
└─ Evidence availability continuously low

Recovery Actions:
├─ Increase priority score
├─ Expand search parameters for evidence
├─ Generate alternative child queries
└─ Manual review flagging
```

 Monitoring and Analytics

### Success Metrics

```
Query Management KPIs:
├─ Resolution Rate: % queries resolved within timeout
├─ Processing Efficiency: Average time from PENDING to RESOLVED
├─ Resource Utilization: Database size vs. query processing performance
├─ Dependency Accuracy: % child queries contributing to parent resolution
└─ Priority Effectiveness: Correlation between priority score and resolution success
```

### Performance Monitoring

```
Tracking Metrics:
├─ Query state changes over time
├─ Resource consumption patterns
├─ Dependency graph complexity
├─ Resolution statement quality
└─ Pruning effectiveness
```

Query Management provides the systematic research foundation that transforms AI from reactive question answering to proactive evidence gathering, ensuring comprehensive, focused investigation of complex topics through intelligent lifecycle management and resource optimization.
