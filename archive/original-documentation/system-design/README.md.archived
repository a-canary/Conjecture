---
archived: 2024-10-30
reason: Content consolidated into new unified documentation
consolidated_into: SystemArchitecture.md
migration_status: complete
quality_note: Replaced by higher-quality unified documentation
---

# Conjecture Architecture Documentation

## System Overview

Conjecture reimagines AI agent systems by replacing conversational memory with evidence-based reasoning, enabling reliable intelligence that grows stronger with each interaction rather than fading over time. The architecture transforms how agents understand context, discover capabilities, and execute actions through semantic intelligence rather than conversation history.

## Documentation Structure

### 10-Document Functional Architecture

**Overview.md** - Architecture Vision and Philosophy (≈1000 words)
The complete system overview explaining core philosophy, architectural vision, design principles, key innovations, business value, and success metrics. Provides the foundation understanding for all components.

**Design-Decision-Registry.md** - Architectural Rationale and Trade-offs (≈800 words)
Documentation of key design decisions with problem context, alternatives considered, chosen solutions, constraints, and evolution guidance. Essential for understanding architectural intent and implementation rationale.

**Evidence-Structure.md** - Claims Architecture (≈800 words)
Claims with confidence scoring and source provenance, embedding generation, deduplication algorithm, and group-think bias prevention. Handles claim lifecycle management and quality control.

**Query-Management.md** - Query Lifecycle Control (≈900 words)
Query states (PENDING, PROCESSING, RESOLVED, ORPHANED), priority scoring, child query generation, dependency management, and resource limits with intelligent pruning strategies.

**Skills-Architecture.md** - Capability Structure and Discovery (≈900 words)
Unified skill.md file structure, dual execution paths (Python functions + subprocess), semantic discovery system, Skills Registry, and permission framework with security manifests.

**Skill-Creation.md** - Skill Gap Detection and Expansion (≈900 words)
Automatic skill gap detection algorithm, child query generation for skill brainstorming, user approval workflows, LLM skill proposal generation, and skill integration processes.

**Semantic-Matching.md** - Action Processing and Selection (≈800 words)
Semantic action generation, embedding comparison algorithms, sum-ranking skill selection, confidence-driven selection, and integration with skill gap detection.

**Tool-Execution.md** - Single-Threaded Execution and Streaming (≈800 words)
Single-threaded tool execution philosophy, streaming response processing with chunking, query-threaded conversations, note-taking system, and resource management.

**Resolution-Context.md** - Resolution Statements and Context Gathering (≈800 words)
Structured resolution statement format and system generation, hybrid context gathering strategy (direct children + recent), query lineage tracking, and benefits over conversation compression.

**Integration-Interface.md** - Component Communication and APIs (≈1000 words)
Evidence Management APIs, Capability System APIs, Processing Engine APIs, cross-component communication protocols, security standards, and performance requirements.

**Implementation-Guide.md** - Deployment and Operations (≈1000 words)
System requirements, deployment architecture, configuration management, security setup, performance optimization, monitoring, backup strategies, and troubleshooting procedures.

**Design-Decision-Registry.md** - Architectural Rationale and Trade-offs (≈800 words)
Documentation of key design decisions with problem context, alternatives considered, chosen solutions, constraints, and evolution guidance. Essential for understanding architectural intent and implementation rationale.

**Design-to-Requirements-Transition.md** - Implementation Planning Bridge (≈600 words)
Framework for translating design decisions into system requirements, use cases, and implementation plans. Provides structured approach for development teams transitioning from architecture to implementation.

## Document Relationships

```
Conjecture Architecture
├─ Overview.md (Foundation & Philosophy)
│  └─ Provides high-level context and design principles
├─ Evidence Layer (Knowledge Foundation)
│  ├─ Evidence-Structure.md → Claims architecture & scoring
│  └─ Query-Management.md → Query lifecycle & resource control
├─ Capability Layer (Tool Foundation)
│  ├─ Skills-Architecture.md → Skill structure & discovery
│  └─ Skill-Creation.md → Gap detection & expansion
├─ Processing Layer (Orchestration Engine)
│  ├─ Semantic-Matching.md → Action processing & selection
│  ├─ Tool-Execution.md → Single-threaded execution & streaming
│  └─ Resolution-Context.md → Resolution statements & gathering
├─ Integration Layer (System Communication)
├─ Integration-Interface.md → APIs & component communication
└─ Operations Layer (Deployment & Maintenance)
    ├─ Implementation-Guide.md → Deployment configuration & operations
    ├─ Design-Decision-Registry.md → Architectural rationale & evolution guidance
    └─ Design-to-Requirements-Transition.md → Requirements development framework
```

## Reading Paths

### For Architects and Decision Makers
Start with **Overview.md** to understand the complete vision and business value, then read any component documents based on specific interests.

### For Developers and Implementers
1. **Overview.md** - Understand the overall architecture and philosophy
2. **Evidence-Structure.md** - Master claims architecture and confidence scoring
3. **Query-Management.md** - Learn query lifecycle and resource management
4. **Skills-Architecture.md** - Understand skill structure and semantic discovery
5. **Skill-Creation.md** - Master skill gap detection and user approval workflows
6. Semantic-Matching.md - Learn action processing and skill selection algorithms
7. Tool-Execution.md - Master streaming tool execution and single-threaded processing
8. Resolution-Context.md - Understand resolution statements and context gathering
9. Integration-Interface.md - Master component communication and API specifications
10. Implementation-Guide.md - Learn deployment, configuration, and operational procedures
11. Design-Decision-Registry.md - Understand architectural rationale and trade-offs for requirements planning
12. Design-to-Requirements-Transition.md - Map design decisions to implementation plans

### For System Administrators
1. **Overview.md** - High-level understanding
2. **Evidence-Management.md** - Resource management and database operations
3. **Capability-System.md** - Permission framework and security
4. **Processing-Engine.md** - Performance monitoring and optimization

## Glossary of Core Concepts

**Claims**: Factual statements with confidence scores and source provenance, inheriting uncertainty through semantic validation.

**Confidence Scoring**: Trust metric assigned based on source methodology (Primary 0.95, Validated 0.85, Credible 0.70, Unverified 0.30, Assumptions 0.10-0.20).

**ContextMap**: The evidence foundation that maintains persistent claims with semantic search capabilities and query lifecycle management.

**Queries**: Research questions managed through states: PENDING, PROCESSING, RESOLVED, ORPHANED (maximum 20 per response).

**Resolution Statements**: Structured milestones documenting query progress, intent, actions, and impact, providing operational lineage without conversation compression.

**Skills**: Self-describing capability packages with semantic discovery, dual execution paths, and permission manifests for sensitive operations.

**Design Decision Registry**: Documentation of architectural rationale, alternatives considered, and evolution guidance for implementation teams.

**Design-to-Requirements Transition**: Framework for translating architectural decisions into actionable system requirements and implementation plans.

**Skills Registry**: Pre-computed index of all skill capabilities with embeddings for fast semantic matching.

**Skill Gap Detection**: Automatic identification of capability gaps with child query generation for skill brainstorming and user approval.

**SemanticRecall**: The processing engine that transforms context through semantic understanding and capability matching with resolution tracking.

**Hybrid Context Gathering**: Strategy combining direct child resolution statements with last 5 recent statements for optimal context building.

**Query-Threaded Conversations**: Separate conversation threads per query for tool interactions, with structured data refresh each prompt cycle.

**Streaming Tool Responses**: Chunked processing of large tool responses with note-taking to handle extensive content without context limits.

## Architecture Mental Model

```
┌─ Evidence Layer (Evidence-Management)
│  └─ Stores claims, manages queries, provides provenance
│
├─ Capability Layer (Capability-System)
│  └─ Defines skills, detects gaps, manages permissions
│
└─ Processing Layer (Processing-Engine)
   └─ Processes semantically, executes tools, tracks resolutions
```

## System Flow Summary

1. **Context Input**: User request becomes query with evidence context
2. **Evidence Gathering**: Claims retrieved with confidence scoring and relevance
3. **Semantic Processing**: Actions generated and matched against available capabilities
4. **Capability Execution**: Skills executed through streaming responses with note-taking
5. **Resolution Tracking**: Structured milestones document progress and outcomes
6. **Evidence Growth**: New claims added to persistent evidence base
7. **Capability Expansion**: Gap detection triggers skill creation when needed

## Design Philosophy

### Evidence Over Conversation
Transform from conversation memory loss to cumulative evidence growth, where every conclusion traces to specific sources.

### Self-Improving Capabilities
Automatically detect capability gaps and create new skills through user-guided expansion, continuously improving system abilities.

### Semantic Intelligence
Use conceptual understanding rather than keyword matching, enabling natural capability discovery and dynamic orchestration.

### Permission-Aware Security
Capabilities declare security requirements upfront with user consent workflows for sensitive operations.

### Resource-Constrained Intelligence
Operate under strict limits with intelligent pruning, maintaining efficiency without sacrificing capability.

## Quick Reference

| Concept | Primary Document | Key Purpose |
|---------|------------------|-------------|
| Evidence Foundation | Evidence-Structure.md | Claims with confidence scoring and source provenance |
| Query Lifecycle | Query-Management.md | Query states, priority scoring, and resource management |
| Skill Architecture | Skills-Architecture.md | Unified skill files with semantic discovery and dual execution |
| Permission Framework | Skills-Architecture.md | User consent workflows and security manifests |
| Skill Gap Detection | Skill-Creation.md | Automatic capability gap identification and expansion |
| Semantic Matching | Semantic-Matching.md | Action generation and confidence-driven skill selection |
| Single-Threaded Execution | Tool-Execution.md | Sequential tool processing with streaming responses |
| Query-Threaded Conversations | Tool-Execution.md | Structured tool interactions with evidence context refresh |
| Resolution Statements | Resolution-Context.md | Structured milestones for operational lineage tracking |
| Hybrid Context Gathering | Resolution-Context.md | Direct child + recent resolution context strategy |
| Component Communication | Integration-Interface.md | APIs, security protocols, and cross-component data flow |
| Deployment Configuration | Implementation-Guide.md | System setup, security, monitoring, and maintenance |
| Architectural Rationale | Design-Decision-Registry.md | Design intent, alternatives considered, and evolution guidance |
| Implementation Planning | Design-to-Requirements-Transition.md | Requirements development and implementation sequencing |

## Implementation Considerations

### Resource Management
- Database limits: Default 500MB with intelligent pruning strategies
- Query limits: Maximum 20 queries per response with priority scoring
- Execution timeouts: 60 seconds default for single-threaded tool operations
- Response chunking: 1000 tokens per processing cycle for streaming responses
- Resource constraints: Controlled memory and CPU allocation per component

### Security Model
- Trusted environment: User operates system with trusted LLM provider and secure execution
- Permission manifests: Skills declaratively declare security requirements upfront
- User consent workflows: Required for sensitive operations (file access, skill creation)
- Audit trails: Complete logging for operational tracking and compliance
- Component isolation: Each layer operates with controlled security boundaries

### Performance Optimization
- Caching strategies: Embedding caching, skill similarity caching, response chunking
- Single-threaded execution: Predictable resource usage and simple debugging
- Streaming responses: Handle large tool responses without context window limits
- Hybrid context: Optimized context building with resolution statements
- Index management: Efficient vector similarity and relationship indexing

For complete understanding of any component, refer to its dedicated document. The glossary above provides unified definitions across all architecture elements.

**Last Updated**: Complete 10-document functional architecture with implementation specifications
**Version**: 2.0.0 - Evidence-based processing with self-improving capabilities and comprehensive operational guidance
